# AI एजेंट्स के लिए मेमोरी  
[![Agent Memory](../../../translated_images/hi/lesson-13-thumbnail.959e3bc52d210c64.webp)](https://youtu.be/QrYbHesIxpw?si=qNYW6PL3fb3lTPMk)

जब AI एजेंट्स बनाने के अनोखे लाभों पर चर्चा की जाती है, तो मुख्य रूप से दो चीजें चर्चा में आती हैं: कार्य पूरा करने के लिए टूल कॉल करने की क्षमता और समय के साथ सुधार करने की क्षमता। मेमोरी उस आधारशिला पर होती है जो एक स्व-सुधार करने वाले एजेंट को बनाने में मदद करती है जो हमारे उपयोगकर्ताओं के लिए बेहतर अनुभव बना सके।

इस पाठ में, हम देखेंगे कि AI एजेंट्स के लिए मेमोरी क्या है और हम इसे कैसे प्रबंधित कर सकते हैं और हमारे अनुप्रयोगों के लाभ के लिए इसका उपयोग कर सकते हैं।

## परिचय

यह पाठ निम्नलिखित विषयों को कवर करेगा:

• **AI एजेंट मेमोरी को समझना**: मेमोरी क्या है और यह एजेंट्स के लिए क्यों आवश्यक है।

• **मेमोरी को लागू करना और संग्रहित करना**: अपने AI एजेंट्स में मेमोरी क्षमताएं जोड़ने के व्यावहारिक तरीके, जिसमें शॉर्ट-टर्म और लॉन्ग-टर्म मेमोरी पर विशेष ध्यान।

• **AI एजेंट्स को स्व-सुधार करना**: मेमोरी कैसे एजेंट्स को पिछले अंतःक्रियाओं से सीखने और समय के साथ सुधार करने में सक्षम बनाती है।

## उपलब्ध कार्यान्वयन

यह पाठ दो व्यापक नोटबुक ट्यूटोरियल्स शामिल करता है:

• **[13-agent-memory.ipynb](./13-agent-memory.ipynb)**: Mem0 और Azure AI Search के साथ Semantic Kernel फ्रेमवर्क का उपयोग करके मेमोरी को लागू करता है

• **[13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)**: Cognee का उपयोग करके संरचित मेमोरी लागू करता है, एम्बेडिंग से समर्थित ऑटोमेटिक ज्ञान ग्राफ बनाना, ग्राफ का विज़ुअलीकरण करना, और बुद्धिमान पुनर्प्राप्ति

## सीखने के लक्ष्य

इस पाठ को पूरा करने के बाद, आप जानेंगे कि कैसे:

• **विभिन्न प्रकार की AI एजेंट मेमोरी के बीच अंतर करना है**, जिसमें कार्यशील, अल्पकालिक, और दीर्घकालिक मेमोरी के साथ-साथ विशेष रूपों जैसे कि पर्सोना और एपिसोडिक मेमोरी शामिल हैं।

• **Semantic Kernel फ्रेमवर्क का उपयोग करके AI एजेंट्स के लिए अल्पकालिक और दीर्घकालिक मेमोरी को लागू और प्रबंधित करना**, Mem0, Cognee, व्हाइटबोर्ड मेमोरी जैसे टूल्स का लाभ उठाना, और Azure AI Search के साथ एकीकरण करना।

• **स्व-सुधार करने वाले AI एजेंट्स के सिद्धांतों को समझना** और कैसे मजबूत मेमोरी प्रबंधन प्रणाली निरंतर सीखने और अनुकूलन में योगदान देती हैं।

## AI एजेंट मेमोरी को समझना

मूल रूप से, **AI एजेंट्स के लिए मेमोरी उन तंत्रों को संदर्भित करती है जो उन्हें जानकारी बनाए रखने और पुनः कॉल करने की अनुमति देते हैं**। यह जानकारी बातचीत के विशिष्ट विवरण, उपयोगकर्ता प्राथमिकताओं, पिछले कार्यों या यहां तक कि सीखे हुए पैटर्न भी हो सकती है।

मेमोरी के बिना, AI अनुप्रयोग अक्सर स्टेटलेस होते हैं, जिसका मतलब है कि प्रत्येक अंतःक्रिया नए सिरे से शुरू होती है। इससे एक दोहरावदार और निराशाजनक उपयोगकर्ता अनुभव होता है जहां एजेंट पिछले संदर्भ या प्राथमिकताओं "को भूल जाता है"।

### मेमोरी क्यों महत्वपूर्ण है?

एजेंट की बुद्धिमत्ता गहराई से इसकी पिछले जानकारी को पुनः प्राप्त करने और उपयोग करने की क्षमता से जुड़ी होती है। मेमोरी एजेंट्स को यह अनुमति देती है कि वे:

• **परावर्तित करें**: पिछले कार्यों और परिणामों से सीखना।

• **इंटरएक्टिव रहें**: चल रही बातचीत में संदर्भ बनाए रखना।

• **सक्रिय और प्रतिक्रियाशील हों**: ऐतिहासिक डेटा के आधार पर ज़रूरतों की भविष्यवाणी करना या उचित प्रतिक्रिया देना।

• **स्वतंत्र हों**: संगृहीत ज्ञान का उपयोग करके अधिक स्वतंत्र रूप से संचालित होना।

मेमोरी को लागू करने का लक्ष्य एजेंट्स को अधिक **विश्वसनीय और सक्षम** बनाना है।

### मेमोरी के प्रकार

#### कार्यशील मेमोरी (Working Memory)

इसे एक स्क्रैच पेपर की तरह सोचें जिसका एक एजेंट एकल, चल रहे कार्य या विचार प्रक्रिया के दौरान उपयोग करता है। यह अगले कदम की गणना के लिए आवश्यक तात्कालिक जानकारी रखता है।

AI एजेंट्स के लिए, कार्यशील मेमोरी अक्सर बातचीत से सबसे प्रासंगिक जानकारी कैप्चर करती है, भले ही पूरा चैट इतिहास लंबा या कटऑफ़्ड हो। यह आवश्यकताएँ, प्रस्ताव, निर्णय और क्रियाओं जैसे मुख्य तत्वों को निकालने पर केंद्रित होती है।

**कार्यशील मेमोरी का उदाहरण**

एक यात्रा बुकिंग एजेंट में, कार्यशील मेमोरी उपयोगकर्ता की मौजूदा अनुरोध को पकड़ सकती है, जैसे "मैं पेरिस के लिए ट्रिप बुक करना चाहता हूं"। यह विशिष्ट आवश्यकता एजेंट के तत्काल संदर्भ में रखी जाती है ताकि वर्तमान अंतःक्रिया को मार्गदर्शन मिल सके।

#### अल्पकालिक मेमोरी (Short Term Memory)

यह प्रकार की मेमोरी एकल बातचीत या सत्र की अवधि के लिए जानकारी रखती है। यह वर्तमान चैट का संदर्भ है, जिससे एजेंट बातचीत के पिछले चरणों को संदर्भित कर सकता है।

**अल्पकालिक मेमोरी का उदाहरण**

अगर उपयोगकर्ता पूछता है, "पेरिस के लिए उड़ान की कीमत कितनी होगी?" और फिर पूछता है, "वहां ठहरने का क्या?" तो अल्पकालिक मेमोरी सुनिश्चित करती है कि एजेंट जानता है कि "वहां" का मतलब उसी बातचीत में "पेरिस" है।

#### दीर्घकालिक मेमोरी (Long Term Memory)

यह वह जानकारी है जो कई बातचीत या सत्रों में बनी रहती है।यह एजेंट्स को उपयोगकर्ता की प्राथमिकताएं, ऐतिहासिक अंतःक्रियाएं या विस्तारित अवधि में सामान्य ज्ञान याद रखने की अनुमति देती है। यह वैयक्तिकरण के लिए महत्वपूर्ण है।

**दीर्घकालिक मेमोरी का उदाहरण**

एक दीर्घकालिक मेमोरी यह स्टोर कर सकती है कि "बेन स्कीइंग और आउटडोर गतिविधियां पसंद करता है, कॉफी को पहाड़ के दृश्य के साथ पसंद करता है, और पिछले चोट के कारण उन्नत स्की ढलानों से बचना चाहता है"। पिछली बातचीत से सीखी गई यह जानकारी भविष्य की यात्रा योजना सत्रों में सिफारिशों को अत्यधिक व्यक्तिगत बनाती है।

#### पर्सोना मेमोरी (Persona Memory)

यह विशिष्ट मेमोरी प्रकार एजेंट को एक सुसंगत "व्यक्तित्व" या "पर्सोना" विकसित करने में मदद करता है। यह एजेंट को खुद के बारे में या उसके नियोजित भूमिका के बारे में विवरण याद रखने देता है, जिससे अंतःक्रियाएं अधिक सहज और केंद्रित हो जाती हैं।

**पर्सोना मेमोरी का उदाहरण**  
अगर यात्रा एजेंट को एक "विशेषज्ञ स्की योजनाकार" के रूप में डिजाइन किया गया है, तो पर्सोना मेमोरी इस भूमिका को मजबूत कर सकती है, जिससे इसके उत्तर विशेषज्ञ की टोन और ज्ञान के अनुरूप होते हैं।

#### वर्कफ़्लो/एपिसोडिक मेमोरी (Workflow/Episodic Memory)

यह मेमोरी उन चरणों के अनुक्रम को स्टोर करती है जो एक एजेंट जटिल कार्य करते समय लेता है, जिसमें सफलताएं और विफलताएं शामिल हैं। यह विशिष्ट "एपिसोड" या पिछले अनुभव याद करने जैसा है ताकि उनसे सीखा जा सके।

**एपिसोडिक मेमोरी का उदाहरण**  
अगर एजेंट ने किसी विशिष्ट उड़ान को बुक करने का प्रयास किया लेकिन वह अनुपलब्धता के कारण विफल रहा, तो एपिसोडिक मेमोरी इस विफलता को रिकॉर्ड कर सकती है, जिससे अगली बार प्रयास करते समय एजेंट वैकल्पिक उड़ानें आज़मा सके या उपयोगकर्ता को इस मुद्दे के बारे में अधिक सूचित तरीके से बता सके।

#### एंटिटी मेमोरी (Entity Memory)

यह बातचीत से विशिष्ट एंटिटीज़ (जैसे लोग, स्थान, या वस्तुएं) और घटनाओं को निकालने और याद रखने से संबंधित है। यह एजेंट को चर्चा किए गए प्रमुख तत्वों की संरचित समझ बनाने की अनुमति देता है।

**एंटिटी मेमोरी का उदाहरण**

एक पिछली यात्रा के बारे में बातचीत से, एजेंट "पेरिस," "एफिल टॉवर," और "ले शाट नोयर रेस्तरां में डिनर" जैसी एंटिटीज़ निकाल सकता है। भविष्य की बातचीत में, एजेंट "ले शाट नोयर" को याद कर नया आरक्षण करने की पेशकश कर सकता है।

#### संरचित RAG (Retrieval Augmented Generation)

जबकि RAG एक व्यापक तकनीक है, "संरचित RAG" को एक शक्तिशाली मेमोरी तकनीक के रूप में उजागर किया गया है। यह विभिन्न स्रोतों (बातचीत, ईमेल, चित्र) से गहन, संरचित जानकारी निकालता है और इसका उपयोग प्रतिक्रियाओं में सटीकता, पुनः प्राप्ति और गति बढ़ाने के लिए करता है। क्लासिक RAG जो केवल सेमांटिक समानता पर निर्भर करता है, इसके विपरीत संरचित RAG सूचना की अंतर्निहित संरचना के साथ काम करता है।

**संरचित RAG का उदाहरण**

फक्त कीवर्ड मिलान करने के बजाय, संरचित RAG ईमेल से उड़ान विवरण (गंतव्य, तिथि, समय, एयरलाइन) को पार्स कर सकता है और उन्हें संरचित रूप से संग्रहीत कर सकता है। इससे सटीक प्रश्न पूछना संभव होता है जैसे "मैंने मंगलवार को पेरिस के लिए कौन सी उड़ान बुक की थी?"

## मेमोरी को लागू करना और संग्रहित करना

AI एजेंट्स के लिए मेमोरी लागू करना एक व्यवस्थित प्रक्रिया है जो **मेमोरी प्रबंधन** शामिल करता है, जिसमें जानकारी जनरेट करना, संग्रहित करना, पुनः प्राप्त करना, एकीकृत करना, अपडेट करना, और यहां तक कि "भूल जाना" (या हटाना) शामिल है। पुनः प्राप्ति एक विशेष रूप से महत्वपूर्ण पहलू है।

### विशिष्ट मेमोरी टूल्स

#### Mem0

एजेंट मेमोरी को संग्रहित और प्रबंधित करने का एक तरीका है Mem0 जैसे विशिष्ट टूल्स का उपयोग करना। Mem0 एक सतत मेमोरी परत के रूप में काम करता है, जिससे एजेंट्स प्रासंगिक इंटरैक्शन को याद कर पाते हैं, उपयोगकर्ता प्राथमिकताओं और तथ्यात्मक संदर्भ को संग्रहित कर पाते हैं, और समय के साथ सफलताओं और असफलताओं से सीखते हैं। विचार यह है कि स्टेटलेस एजेंट्स को स्टेटफुल एजेंट्स में बदल दिया जाए।

यह **दो-चरणीय मेमोरी पाइपलाइन: निष्कर्षण और अपडेट** के माध्यम से काम करता है। पहले, एजेंट के थ्रेड में जो संदेश जोड़े जाते हैं, वे Mem0 सेवा को भेजे जाते हैं, जो एक बड़े भाषा मॉडल (LLM) का उपयोग करके बातचीत का सारांश बनाता है और नई मेमोरी निकालता है। इसके बाद, एक LLM-संचालित अपडेट चरण निर्धारित करता है कि इन मेमोरी को जोड़ना है, संशोधित करना है, या हटाना है, और इन्हें एक हाइब्रिड डेटा स्टोर में संग्रहित करता है जिसमें वेक्टर, ग्राफ, और की-वैल्यू डेटाबेस शामिल हो सकते हैं। यह सिस्टम विभिन्न मेमोरी प्रकारों का समर्थन करता है और व्यवस्थाओं के बीच संबंधों को प्रबंधित करने के लिए ग्राफ मेमोरी को सम्मिलित कर सकता है।

#### Cognee

एक और शक्तिशाली तरीका है **Cognee** का उपयोग करना, जो AI एजेंट्स के लिए एक ओपन-सोर्स सेमांटिक मेमोरी है जो संरचित और असंरचित डेटा को क्वेरी योग्य ज्ञान ग्राफ में परिवर्तित करता है जो एम्बेडिंग द्वारा समर्थित है। Cognee एक **डुअल-स्टोर आर्किटेक्चर** प्रदान करता है जो वेक्टर समानता खोज को ग्राफ संबंधों के साथ जोड़ता है, जिससे एजेंट्स न केवल यह समझ पाते हैं कि जानकारी समान क्या है, बल्कि अवधारणाएं एक-दूसरे से कैसे संबंधित हैं।

यह **हाइब्रिड पुनः प्राप्ति** में उत्कृष्ट है जो वेक्टर समानता, ग्राफ संरचना, और LLM तर्कशीलता का संयोजन करता है - कच्चे चंक लुकअप से लेकर ग्राफ-सचेत प्रश्नोत्तरी तक। सिस्टम **लिविंग मेमोरी** बनाए रखता है जो विकसित होती रहती है और बढ़ती रहती है जबकि एक जुड़े ग्राफ के रूप में क्वेरीयोग्य बनी रहती है, शॉर्ट-टर्म सत्र संदर्भ और दीर्घकालिक स्थायी मेमोरी दोनों का समर्थन करता है।

Cognee नोटबुक ट्यूटोरियल ([13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)) इस एकीकृत मेमोरी लेयर के निर्माण का प्रदर्शन करता है, जिसमें विभिन्न डेटा स्रोतों को निगलने के व्यावहारिक उदाहरण, ज्ञान ग्राफ का विज़ुअलीकरण, और विशिष्ट एजेंट आवश्यकताओं के अनुसार विभिन्न खोज रणनीतियों के साथ क्वेरी करना शामिल है।

### RAG के साथ मेमोरी संग्रहित करना

Mem0 जैसे विशिष्ट मेमोरी टूल्स के अलावा, आप **Azure AI Search जैसे मजबूत खोज सेवाओं का उपयोग मेमोरी संग्रहण और पुनः प्राप्ति के लिए कर सकते हैं**, खासकर संरचित RAG के लिए।

यह आपके एजेंट की प्रतिक्रियाओं को आपकी अपनी डेटा के साथ आधारित करने की अनुमति देता है, जिससे अधिक प्रासंगिक और सटीक उत्तर सुनिश्चित होते हैं। Azure AI Search का उपयोग विशिष्ट उपयोगकर्ता की यात्रा मेमोरी, उत्पाद कैटलॉग, या किसी अन्य डोमेन-विशिष्ट ज्ञान को संग्रहित करने के लिए किया जा सकता है।

Azure AI Search **संरचित RAG** जैसी क्षमताओं का समर्थन करता है, जो बड़े डेटासेट जैसे बातचीत इतिहास, ईमेल, या यहां तक कि चित्रों से गहन, संरचित जानकारी निकालने और पुनः प्राप्ति में उत्कृष्ट है। यह पारंपरिक टेक्स्ट चंकिंग और एम्बेडिंग दृष्टिकोणों की तुलना में "अतिमानवीय सटीकता और पुनः प्राप्ति" प्रदान करता है।

## AI एजेंट्स को स्व-सुधार करना

स्व-सुधार करने वाले एजेंट्स के लिए सामान्य पैटर्न में एक **"ज्ञान एजेंट"** शामिल होता है। यह अलग एजेंट उपयोगकर्ता और प्राथमिक एजेंट के बीच मुख्य बातचीत का निरीक्षण करता है। इसका कार्य यह है:

1. **मूल्यवान जानकारी की पहचान करना**: यह निर्धारित करना कि क्या बातचीत का कोई भाग सामान्य ज्ञान या विशिष्ट उपयोगकर्ता प्राथमिकता के रूप में सहेजा जाना चाहिए।

2. **निकालना और संक्षेप करना**: बातचीत से आवश्यक सीख या प्राथमिकता को आसंजित करना।

3. **ज्ञान आधार में संग्रहीत करना**: इस निकाली गई जानकारी को आम तौर पर एक वेक्टर डेटाबेस में संरक्षित करना ताकि इसे बाद में पुनः प्राप्त किया जा सके।

4. **भविष्य के प्रश्नों को बढ़ाना**: जब उपयोगकर्ता एक नया प्रश्न प्रारंभ करता है, तो ज्ञान एजेंट प्रासंगिक संग्रहीत जानकारी पुनः प्राप्त करता है और इसे उपयोगकर्ता के प्रॉम्प्ट में संलग्न करता है, प्राथमिक एजेंट को महत्वपूर्ण संदर्भ प्रदान करता है (RAG के समान)।

### मेमोरी के लिए अनुकूलन

• **प्रतिध्वनि प्रबंधन (Latency Management)**: उपयोगकर्ता अंतःक्रियाओं को धीमा होने से रोकने के लिए, एक सस्ता, तेज़ मॉडल प्रारंभिक रूप से यह जांचने के लिए प्रयोग किया जा सकता है कि क्या जानकारी संग्रहित या पुनः प्राप्त करने लायक है, केवल आवश्यक होने पर जटिल निष्कर्षण/पुनः प्राप्ति प्रक्रिया को बुलाते हुए।

• **ज्ञान आधार का रखरखाव**: वृद्धि हो रही ज्ञान आधार के लिए, कम उपयोग की जाने वाली जानकारी को "कोल्ड स्टोरेज" में स्थानांतरित किया जा सकता है ताकि लागत का प्रबंधन किया जा सके।

## एजेंट मेमोरी के बारे में और प्रश्न हैं?

अन्य शिक्षार्थियों से मिलें, ऑफिस आवर्स में भाग लें और अपने AI एजेंट्स से संबंधित प्रश्नों के उत्तर प्राप्त करने के लिए [Azure AI Foundry Discord](https://aka.ms/ai-agents/discord) से जुड़ें।

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**अस्वीकरण**:  
यह दस्तावेज़ एआई अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवादों में त्रुटियाँ या अशुद्धियाँ हो सकती हैं। मूल दस्तावेज़ अपनी मूल भाषा में ही अधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए पेशेवर मानव अनुवाद की सलाह दी जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।
<!-- CO-OP TRANSLATOR DISCLAIMER END -->