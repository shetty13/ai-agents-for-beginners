# ความจำสำหรับเอเย่นต์ AI  
[![Agent Memory](../../../translated_images/th/lesson-13-thumbnail.959e3bc52d210c64.webp)](https://youtu.be/QrYbHesIxpw?si=qNYW6PL3fb3lTPMk)

เมื่อพูดถึงประโยชน์เฉพาะของการสร้างเอเย่นต์ AI จะมีสองเรื่องหลักที่พูดถึง: ความสามารถในการเรียกใช้เครื่องมือเพื่อทำงานให้สำเร็จ และความสามารถในการพัฒนาตัวเองได้ตามกาลเวลา ความจำเป็นพื้นฐานของการสร้างเอเย่นต์ที่พัฒนาตัวเองได้คือการสร้างประสบการณ์ที่ดีขึ้นสำหรับผู้ใช้ของเรา

ในบทเรียนนี้ เราจะดูว่าความจำคืออะไรสำหรับเอเย่นต์ AI และเราจะจัดการและใช้มันเพื่อประโยชน์ของแอปพลิเคชันของเราอย่างไร

## บทนำ

บทเรียนนี้จะครอบคลุม:

• **การเข้าใจความจำของเอเย่นต์ AI**: ความจำคืออะไรและทำไมจึงสำคัญสำหรับเอเย่นต์

• **การติดตั้งและเก็บความจำ**: วิธีปฏิบัติในการเพิ่มความสามารถในการจำให้กับเอเย่นต์ AI ของคุณ โดยเน้นความจำระยะสั้นและระยะยาว

• **การทำให้เอเย่นต์ AI พัฒนาตัวเองได้**: วิธีที่ความจำทำให้เอเย่นต์เรียนรู้จากการโต้ตอบที่ผ่านมาและพัฒนาขึ้นตามกาลเวลา

## การติดตั้งที่มีอยู่

บทเรียนนี้ประกอบด้วยสมุดบันทึกสองชุดที่ครอบคลุม:

• **[13-agent-memory.ipynb](./13-agent-memory.ipynb)**: ติดตั้งความจำโดยใช้ Mem0 และ Azure AI Search ร่วมกับโครงสร้าง Semantic Kernel

• **[13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)**: ติดตั้งความจำที่มีโครงสร้างโดยใช้ Cognee สร้างกราฟความรู้ที่รองรับด้วย embeddings อัตโนมัติ แสดงผลกราฟ และดึงข้อมูลอย่างชาญฉลาด

## เป้าหมายการเรียนรู้

หลังจากเรียนบทเรียนนี้จบ คุณจะรู้วิธี:

• **แยกแยะระหว่างประเภทของความจำเอเย่นต์ AI ต่างๆ** รวมถึงความจำในการทำงาน ความจำระยะสั้น ความจำระยะยาว และรูปแบบเฉพาะอย่าง persona และ episodic memory

• **ติดตั้งและจัดการความจำระยะสั้นและระยะยาวสำหรับเอเย่นต์ AI** โดยใช้โครงสร้าง Semantic Kernel ใช้เครื่องมืออย่าง Mem0, Cognee, ความจำแบบ Whiteboard และผสานรวมกับ Azure AI Search

• **เข้าใจหลักการเบื้องหลังเอเย่นต์ AI ที่พัฒนาตัวเองได้** และว่าวิธีการจัดการความจำที่แข็งแกร่งช่วยให้การเรียนรู้และการปรับตัวอย่างต่อเนื่องเป็นไปอย่างไร

## การเข้าใจความจำของเอเย่นต์ AI

โดยหลักแล้ว **ความจำสำหรับเอเย่นต์ AI หมายถึงกลไกที่ช่วยให้พวกเขาเก็บและเรียกคืนข้อมูลได้** ข้อมูลนี้อาจเป็นรายละเอียดเฉพาะเกี่ยวกับการสนทนา ความชื่นชอบของผู้ใช้ การกระทำที่ผ่านมา หรือแม้แต่รูปแบบที่เรียนรู้มา

หากไม่มีความจำ แอปพลิเคชัน AI มักจะไม่มีสถานะ หมายความว่าการโต้ตอบแต่ละครั้งจะเริ่มต้นใหม่หมด นำไปสู่ประสบการณ์ผู้ใช้ที่น่าหงุดหงิดและซ้ำซากที่เอเย่นต์ "ลืม" บริบทหรือความชื่นชอบก่อนหน้า

### ทำไมความจำจึงสำคัญ?

ความฉลาดของเอเย่นต์มีความเชื่อมโยงอย่างลึกซึ้งกับความสามารถในการเรียกข้อมูลและใช้ข้อมูลที่ผ่านมา ความจำทำให้เอเย่นต์สามารถ:

• **สะท้อนความคิด**: เรียนรู้จากการกระทำและผลลัพธ์ที่ผ่านมา

• **มีปฏิสัมพันธ์**: รักษาบริบทในระหว่างการสนทนาที่กำลังดำเนินอยู่

• **เชิงรุกและตอบสนอง**: คาดการณ์ความต้องการหรือโต้ตอบอย่างเหมาะสมตามข้อมูลในอดีต

• **ทำงานได้โดยอิสระ**: ปฏิบัติงานอย่างเป็นอิสระมากขึ้นโดยดึงความรู้ที่จัดเก็บไว้

เป้าหมายของการติดตั้งความจำคือการทำให้เอเย่นต์มีความน่าเชื่อถือและมีความสามารถมากขึ้น

### ประเภทของความจำ

#### Working Memory

คิดว่าคล้ายกับกระดาษร่างที่เอเย่นต์ใช้ในระหว่างงานหรือกระบวนความคิดหนึ่งครั้ง มันเก็บข้อมูลทันทีที่ต้องใช้ในการคำนวณขั้นตอนถัดไป

สำหรับเอเย่นต์ AI working memory มักจับข้อมูลที่เกี่ยวข้องที่สุดจากการสนทนา แม้ว่าประวัติการแชททั้งหมดจะยาวหรือถูกตัดทอน มันจะเน้นการดึงองค์ประกอบหลัก เช่น ข้อกำหนด ข้อเสนอ การตัดสินใจ และการกระทำ

**ตัวอย่าง Working Memory**

ในเอเย่นต์จองทริป working memory อาจจับคำขอปัจจุบันของผู้ใช้ เช่น "ฉันต้องการจองทริปไปปารีส" ข้อกำหนดเฉพาะนี้ถูกเก็บไว้ในบริบททันทีของเอเย่นต์เพื่อชี้นำการโต้ตอบในขณะนั้น

#### Short Term Memory

ความจำชนิดนี้เก็บข้อมูลไว้ตลอดระยะเวลาการสนทนาหรือเซสชันเดียว เป็นบริบทของการแชทปัจจุบัน ช่วยให้เอเย่นต์สามารถอ้างอิงย้อนหลังไปยังเทิร์นก่อนหน้าในการสนทนาได้

**ตัวอย่าง Short Term Memory**

ถ้าผู้ใช้ถามว่า "ตั๋วเครื่องบินไปปารีสราคาเท่าไหร่?" แล้วตามด้วย "ที่พักที่นั่นล่ะ?" ความจำระยะสั้นจะทำให้เอเย่นต์รู้ว่า "ที่นั่น" หมายถึง "ปารีส" ในการสนทนาเดียวกัน

#### Long Term Memory

นี่คือข้อมูลที่คงอยู่ในหลายการสนทนาหรือหลายเซสชัน ช่วยให้เอเย่นต์จำความชอบของผู้ใช้ การโต้ตอบในอดีตหรือความรู้ทั่วไปในระยะยาว สำคัญสำหรับการปรับแต่งผู้ใช้

**ตัวอย่าง Long Term Memory**

ความจำระยะยาวอาจเก็บข้อมูลว่า "Ben ชอบเล่นสกีและกิจกรรมกลางแจ้ง ชอบกาแฟพร้อมวิวภูเขา และต้องการหลีกเลี่ยงทางลาดสกีขั้นสูงเนื่องจากอาการบาดเจ็บที่ผ่านมา" ข้อมูลนี้ที่เรียนรู้จากการโต้ตอบก่อนหน้าจะมีผลต่อคำแนะนำในแผนการเดินทางในอนาคต ทำให้เป็นการปรับแต่งเฉพาะบุคคลสูง

#### Persona Memory

ความจำเฉพาะนี้ช่วยให้เอเย่นต์พัฒนาบุคลิกภาพหรือ "persona" ที่สม่ำเสมอ ช่วยให้เอเย่นต์จำรายละเอียดเกี่ยวกับตัวเองหรือบทบาทที่ตั้งใจไว้ ทำให้การโต้ตอบราบรื่นและเน้นเป้าหมายมากขึ้น

**ตัวอย่าง Persona Memory**  
ถ้าเอเย่นต์ท่องเที่ยวถูกออกแบบให้เป็น "นักวางแผนสกีผู้เชี่ยวชาญ" persona memory อาจเสริมบทบาทนี้ ส่งผลต่อการตอบกลับที่สอดคล้องกับน้ำเสียงและความรู้ของผู้เชี่ยวชาญ

#### Workflow/Episodic Memory

ความจำนี้จัดเก็บลำดับขั้นตอนที่เอเย่นต์ใช้ระหว่างการทำงานที่ซับซ้อน รวมถึงความสำเร็จและความล้มเหลว เหมือนกับการจำ "ตอน" หรือประสบการณ์ที่ผ่านมาเพื่อนำมาเรียนรู้

**ตัวอย่าง Episodic Memory**

ถ้าเอเย่นต์พยายามจองเที่ยวบินเฉพาะแต่ล้มเหลวเนื่องจากไม่มีที่ว่าง episodic memory สามารถบันทึกความล้มเหลวนี้ ทำให้เอเย่นต์สามารถลองเที่ยวบินทางเลือกหรือแจ้งผู้ใช้เกี่ยวกับปัญหาอย่างชัดเจนในการพยายามครั้งถัดไป

#### Entity Memory

เกี่ยวข้องกับการดึงและจดจำเอนทิตีเฉพาะ (เช่น บุคคล สถานที่ หรือสิ่งของ) และเหตุการณ์จากการสนทนา ช่วยให้เอเย่นต์สร้างความเข้าใจที่มีโครงสร้างขององค์ประกอบสำคัญที่พูดคุยกัน

**ตัวอย่าง Entity Memory**

จากการสนทนาเกี่ยวกับทริปที่ผ่านมา เอเย่นต์อาจดึงคำว่า "ปารีส," "หอไอเฟล," และ "ดินเนอร์ที่ร้าน Le Chat Noir" ออกมาเป็นเอนทิตี ในการโต้ตอบครั้งหน้า เอเย่นต์อาจจำ "Le Chat Noir" ได้และเสนอที่จะทำการจองใหม่ที่นั่น

#### Structured RAG (Retrieval Augmented Generation)

แม้ว่า RAG จะเป็นเทคนิคที่กว้างกว่า แต่ "Structured RAG" ถูกเน้นว่าเป็นเทคโนโลยีความจำที่ทรงพลัง มันดึงข้อมูลหนาแน่นและมีโครงสร้างจากแหล่งข้อมูลหลากหลาย (การสนทนา, อีเมล, รูปภาพ) และใช้เพื่อเพิ่มความแม่นยำ การเรียกคืน และความเร็วในการตอบกลับ แตกต่างจาก RAG แบบคลาสสิกที่พึ่งพาความคล้ายคลึงเชิงความหมาย Structured RAG ทำงานกับโครงสร้างของข้อมูลโดยตรง

**ตัวอย่าง Structured RAG**

แทนที่จะจับคู่แค่คำสำคัญ Structured RAG สามารถแยกข้อมูลเที่ยวบิน (จุดหมาย วันที่ เวลา สายนาย) จากอีเมลและเก็บข้อมูลในรูปแบบโครงสร้าง วิธีนี้ช่วยให้สามารถสอบถามที่แม่นยำเช่น "ฉันจองเที่ยวบินไปปารีสวันอังคารวันไหน?"

## การติดตั้งและเก็บความจำ

การติดตั้งความจำสำหรับเอเย่นต์ AI เกี่ยวข้องกับกระบวนการจัดการความจำอย่างเป็นระบบ ซึ่งรวมถึงการสร้าง เก็บ ดึงข้อมูล บูรณาการ อัปเดต และแม้แต่ "ลืม" (หรือลบ) ข้อมูล การดึงข้อมูลเป็นส่วนที่สำคัญมาก

### เครื่องมือความจำเฉพาะ

#### Mem0

วิธีหนึ่งในการเก็บและจัดการความจำของเอเย่นต์คือการใช้เครื่องมือเฉพาะอย่าง Mem0 Mem0 ทำงานเป็นชั้นความจำถาวร ทำให้เอเย่นต์สามารถเรียกข้อมูลการโต้ตอบที่เกี่ยวข้อง เก็บความชอบของผู้ใช้และบริบทข้อเท็จจริง และเรียนรู้จากความสำเร็จและความล้มเหลวตามกาลเวลา แนวคิดคือการเปลี่ยนเอเย่นต์ที่ไม่มีสถานะให้เป็นเอเย่นต์ที่มีสถานะ

มันทำงานผ่าน **ท่อความจำสองขั้นตอน: การสกัดและการอัปเดต** ขั้นแรก ข้อความที่เพิ่มเข้ามาในกระทู้ของเอเย่นต์จะถูกส่งไปยังบริการ Mem0 ซึ่งใช้ Large Language Model (LLM) สรุปประวัติการสนทนาและสกัดความจำใหม่ จากนั้น ขั้นตอนการอัปเดตที่ขับเคลื่อนด้วย LLM จะตัดสินใจว่าจะเพิ่ม แก้ไข หรือลบความจำเหล่านี้ โดยเก็บไว้ในไดเรกทอรีข้อมูลฮาร์บริด ซึ่งอาจรวมถึงฐานข้อมูลเวกเตอร์ กราฟ และคีย์-ค่า ระบบนี้ยังรองรับความจำหลายชนิดและสามารถผสานรวมความจำรูปแบบกราฟเพื่อจัดการความสัมพันธ์ระหว่างเอนทิตี

#### Cognee

อีกแนวทางทรงพลังคือการใช้ **Cognee** ความจำเชิงความหมายแบบโอเพนซอร์สสำหรับเอเย่นต์ AI ที่เปลี่ยนข้อมูลมีโครงสร้างและไม่มีโครงสร้างเป็นกราฟความรู้ที่สามารถสืบค้นได้โดยอิงกับ embeddings Cognee มีสถาปัตยกรรมแบบเก็บข้อมูลคู่ที่รวมการค้นหาความเหมือนด้วยเวกเตอร์กับความสัมพันธ์ของกราฟ ทำให้เอเย่นต์สามารถเข้าใจไม่ใช่แค่ข้อมูลที่เหมือนกัน แต่ยังรวมถึงความสัมพันธ์ระหว่างแนวคิดต่าง ๆ

มันโดดเด่นที่ **การดึงข้อมูลแบบไฮบริด** ที่ผสมผสานความเหมือนด้วยเวกเตอร์ โครงสร้างกราฟ และเหตุผลของ LLM – ตั้งแต่การค้นหาชิ้นข้อมูลดิบจนถึงการตอบคำถามที่ตระหนักถึงกราฟ ระบบนี้รักษา **ความจำที่มีชีวิต** ที่พัฒนาและเติบโตไปพร้อมกันพร้อมยังสามารถสืบค้นเป็นกราฟเชื่อมต่อเดียว สนับสนุนทั้งบริบทเซสชันระยะสั้นและความจำถาวรระยะยาว

สมุดบันทึก Cognee tutorial ([13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)) แสดงการสร้างชั้นความจำรวมนี้ พร้อมตัวอย่างปฏิบัติการที่นำเข้าข้อมูลหลากหลาย แสดงผลกราฟความรู้ และสืบค้นด้วยกลยุทธ์ค้นหาที่ปรับให้เหมาะกับความต้องการของเอเย่นต์แต่ละตัว

### การเก็บความจำด้วย RAG

นอกเหนือจากเครื่องมือความจำเฉพาะอย่าง Mem0 คุณยังสามารถใช้บริการค้นหาที่แข็งแกร่ง เช่น **Azure AI Search เป็น backend สำหรับเก็บและดึงความจำ** โดยเฉพาะในกรณี Structured RAG

สิ่งนี้ช่วยให้คุณสามารถยืนยันคำตอบของเอเย่นต์ด้วยข้อมูลของคุณเอง รับประกันคำตอบที่เกี่ยวข้องและแม่นยำมากขึ้น Azure AI Search สามารถใช้เก็บความจำการเดินทางเฉพาะผู้ใช้ แคตตาล็อกสินค้า หรือความรู้เฉพาะโดเมนอื่นๆ

Azure AI Search รองรับความสามารถอย่าง **Structured RAG** ที่โดดเด่นในการสกัดและดึงข้อมูลที่หนาแน่นและมีโครงสร้างจากชุดข้อมูลขนาดใหญ่ เช่น ประวัติการสนทนา อีเมล หรือแม้แต่ภาพ สิ่งนี้ทำให้มี "ความแม่นยำและการเรียกคืนเหนือมนุษย์" เมื่อเทียบกับวิธีการแบ่งชิ้นข้อความและฝังข้อมูลแบบดั้งเดิม

## ทำให้เอเย่นต์ AI พัฒนาตัวเองได้

รูปแบบทั่วไปของเอเย่นต์ที่พัฒนาตัวเองได้เกี่ยวข้องกับการแนะนำ **"เอเย่นต์ความรู้"** เอเย่นต์แยกตัวนี้สังเกตการสนทนาหลักระหว่างผู้ใช้กับเอเย่นต์หลัก หน้าที่ของมันคือ:

1. **ระบุข้อมูลที่มีค่า**: ตัดสินใจว่าส่วนใดของการสนทนาควรถูกบันทึกเป็นความรู้ทั่วไปหรือตามความชอบของผู้ใช้เฉพาะบุคคล

2. **สกัดและสรุป**: สกัดการเรียนรู้หรือความชอบหลักจากการสนทนา

3. **จัดเก็บในฐานความรู้**: เก็บข้อมูลที่สกัดไว้ในฐานข้อมูลเวกเตอร์ เพื่อให้สามารถดึงกลับมาใช้ภายหลัง

4. **เสริมคำถามในอนาคต**: เมื่อผู้ใช้เริ่มคำถามใหม่ เอเย่นต์ความรู้จะดึงข้อมูลที่เกี่ยวข้องที่เก็บไว้และเพิ่มเข้าไปในคำสั่งของผู้ใช้ เพื่อให้บริบทสำคัญกับเอเย่นต์หลัก (คล้ายกับ RAG)

### การเพิ่มประสิทธิภาพสำหรับความจำ

• **การจัดการความหน่วง**: เพื่อหลีกเลี่ยงการทำให้การโต้ตอบของผู้ใช้ช้าลง สามารถใช้โมเดลที่ถูกกว่าและเร็วกว่าในขั้นต้นเพื่อประเมินอย่างรวดเร็วว่าข้อมูลใดมีค่าที่จะเก็บหรือดึงมา แล้วจึงเรียกใช้กระบวนการสกัด/ดึงข้อมูลที่ซับซ้อนกว่าเมื่อจำเป็นเท่านั้น

• **การดูแลฐานความรู้**: สำหรับฐานความรู้ที่ขยายตัว ข้อมูลที่ใช้บ้างไม่บ่อยอาจถูกย้ายไปยัง "cold storage" เพื่อลดค่าใช้จ่าย

## มีคำถามเพิ่มเติมเกี่ยวกับความจำของเอเย่นต์ไหม?

เข้าร่วม [Azure AI Foundry Discord](https://aka.ms/ai-agents/discord) เพื่อพบกับผู้เรียนคนอื่น ๆ เข้าร่วมชั่วโมงสำนักงาน และรับคำตอบสำหรับคำถามเกี่ยวกับเอเย่นต์ AI ของคุณได้เลย

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ข้อจำกัดความรับผิดชอบ**:
เอกสารฉบับนี้ได้รับการแปลโดยใช้บริการแปลภาษาด้วย AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้มีความถูกต้องให้มากที่สุด แต่โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่ถูกต้อง เอกสารต้นฉบับในภาษาต้นทางถือเป็นแหล่งข้อมูลที่น่าเชื่อถือที่สุด สำหรับข้อมูลสำคัญ แนะนำให้ใช้บริการแปลโดยผู้เชี่ยวชาญที่เป็นมนุษย์ เราจะไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความผิดที่เกิดขึ้นจากการใช้การแปลนี้
<!-- CO-OP TRANSLATOR DISCLAIMER END -->